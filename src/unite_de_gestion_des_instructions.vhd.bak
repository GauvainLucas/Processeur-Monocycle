library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity unite_de_gestion_des_instructions is 
port(
    clk : in std_logic;
    reset : in std_logic;
    nPCsel : in std_logic;
    offset : in std_logic_vector(23 downto 0);
    irq : in std_logic;
    vicpc : in std_logic_vector(31 downto 0);
    irq_end: in std_logic;
    instruction : out std_logic_vector(31 downto 0);
    irq_serv : out std_logic);
end entity;

ARCHITECTURE struct OF unite_de_gestion_des_instructions IS
   signal sPC, sMux, sExtend, sPlusUn , sPlus, lr : std_logic_vector(31 downto 0);
   
BEGIN
    sPlusUn <= std_logic_vector(unsigned(sPC) + to_unsigned(1, 32));
    sPlus <= std_logic_vector(unsigned(sExtend) + unsigned(sPlusUn));

    PC_Extend : entity work.sign_extend(behavioral)
        generic map(24)
        port map(offset, sExtend);
    
   -- PC : entity work.registrePC(behavioral)
     --   port map(clk, reset, sMux, sPC);

   -- Mux : entity work.mux2v1(behavioral)
      --  generic map(32)
        -- port map(sPlusUn, sPlus, nPCsel, sMux);

    instr : entity work.instruction_memory(RTL)
        port map(SPc, instruction);
	
    process (clk, reset)
    begin
        if (reset = '1') then
            sPC <= (others => '0');
            lr <= (others => '0');
            irq_serv <= '0';
        elsif rising_edge(clk) then
            if (irq = '1') then
                sPC <= vicpc;
                lr <= sPC;
                irq_serv <= '1';
            else
                irq_serv <= '0';
                if (irq_end = '1') then
                    sPC <= std_logic_vector(unsigned(lr) + to_unsigned(1, 32));
                    irq_serv <= '0';
                elsif(nPCsel = '1') then
                    sPC <= sPlus;
                else
                    sPC <= sPlusUn;
                end if;
            end if; 
        end if;
    end process;
END architecture;
